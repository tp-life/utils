package stringx

// 失败链（Failure Link）是AC自动机（Aho-Corasick自动机）中的一个重要概念，主要用于优化多模式匹配的速度。

// 在字典树（Trie）中，如果我们在某个节点上匹配失败，我们通常会回到这个节点的父节点，然后继续匹配。但是在AC自动机中，我们引入了失败链的概念，当在某个节点上匹配失败时，我们可以直接跳转到这个节点的失败链所指向的节点，然后继续匹配。这样可以大大提高匹配的速度。

// 失败链的构建规则如下：

// 根节点的失败链指向自己。
// 如果节点A的直接子节点B，那么B的失败链指向根节点。
// 如果节点A通过边x到达节点B，同时，存在一个节点C，他的失败链指向的节点D，D有一个子节点可以通过相同的边x到达，则B的失败链指向D的这个子节点。
// 在使用失败链进行字符串匹配时，如果当前字符无法匹配，我们就沿着失败链向上跳转，直到跳到一个可以匹配的节点，或者跳到根节点为止。

// 通过这种方式，AC自动机可以在O(n)的时间复杂度内完成多模式匹配，其中n是待匹配字符串的长度。这是因为无论我们如何跳转，每个字符最多只会被匹配两次。
// 假设我们有以下几个模式串："he", "she", "his", "hers"，我们可以构建一个如下的字典树（Trie）：

// )
// 在这个字典树中，我们可以添加失败链（Failure Link）：
// root
// |__h
// |  |__e (模式串"he")
// |  |__i
// |     |__s (模式串"his")
// |
// |__s
//    |__h
//       |__e (模式串"she")
// |
// |__r
//    |__s (模式串"hers")
// 根节点的失败链指向自己。
// "h", "s", "r"的失败链都指向根节点，因为他们是根节点的直接子节点。
// "he"的失败链指向根节点，因为根节点有一个可以通过'e'到达的子节点。
// "hi"的失败链指向根节点，因为根节点没有可以通过'i'到达的子节点。
// "his"的失败链指向根节点，因为根节点没有可以通过's'到达的子节点。
// "sh"的失败链指向'h'，因为'h'是根节点的一个子节点，可以通过'h'到达。
// "she"的失败链指向"he"，因为"he"是根节点的一个子节点，可以通过'e'到达。
// "rs"的失败链指向"s"，因为"s"是根节点的一个子节点，可以通过's'到达。
// 这就是一个具体的失败链的例子。在实际的字符串匹配过程中，如果在某个节点上匹配失败，我们就可以直接跳转到这个节点的失败链所指向的节点，然后继续匹配。这样可以大大提高匹配的速度。

// 构建 node 树后采用按层遍历，依次添加 fail 节点，fail 节点可以提供快速查找相同子串
// fail 优先指向下层和自己相同子串的节点（如果不同连续相同的话，则指向根节点中包含当前这个子串的节点）；
// 如果找不到相同的节点则指向跟节点；对于多个连续相同的子串通过每层的串联关系进行连接。
// 例如：
// [
// 1:	"一二三四七",
// 2:	"二三四六",
// 3:	"三五七",
// 4:   "七八九"
//
//	]
//
// 1: 一 指向 根节点
// 1: 二 指向 2:二
// 1: 三 指向 2:三  因为 1:二 匹配到的是 2:二，因此在 2:二的节点当中去找三
// 1: 四 指向 2:四
// 1: 七 指向 4:七
// 2: 二 指向 根节点
// 2: 三 指向 3:三
// 2: 四 指向 根节点
// 2: 六 指向 根节点
// 3: 三 指向 根节点
// 3: 五 指向 根节点
// 3: 七 指向 4:七
// 4: 七 指向 根节点
// 4: 八 指向 根节点
// 4: 九 指向 根节点
// 定义节点类型
type node struct {
	children map[rune]*node // 子节点，用map存储，方便查找。每个字符对应一个子节点。
	fail     *node          // 失败链，用于AC自动机匹配失败时的跳转。当当前字符匹配失败时，可以通过fail指针找到一个最长的可匹配的模式串。
	depth    int            // 节点深度，即节点在字典树中的层级。根节点的深度为0，每往下一层，深度加1。
	end      bool           // 标记该节点是否为一个模式串的结束节点。如果为true，表示到达此节点的路径对应一个模式串。
	raw      string         // 节点对应的字符。
}

// 添加单词到节点
func (n *node) add(word string) {
	chars := []rune(word) // 将单词转为字符数组
	if len(chars) == 0 {
		return
	}

	nd := n // 从根节点开始
	for i, char := range chars {
		if nd.children == nil { // 如果当前节点没有子节点，创建一个新的子节点
			child := new(node)
			child.depth = i + 1                       // 子节点的深度为当前深度+1
			child.raw = string(char)                  // 子节点对应的字符
			nd.children = map[rune]*node{char: child} // 将子节点添加到当前节点的子节点列表中
			nd = child                                // 移动到子节点
		} else if child, ok := nd.children[char]; ok { // 如果当前节点有一个与当前字符相同的子节点，那么就移动到那个子节点
			nd = child
		} else { // 如果当前节点没有与当前字符相同的子节点，那么就创建一个新的子节点
			child := new(node)
			child.raw = string(char)  // 子节点对应的字符
			child.depth = i + 1       // 子节点的深度为当前深度+1
			nd.children[char] = child // 将子节点添加到当前节点的子节点列表中
			nd = child                // 移动到子节点
		}
	}

	nd.end = true // 标记为结束节点，表示一个模式串的结束
}

// 构建节点
func (n *node) build() {
	var nodes []*node                  // 用于存储待处理的节点
	for _, child := range n.children { // 遍历根节点的所有子节点
		child.fail = n               // 子节点的失败链指向根节点
		nodes = append(nodes, child) // 将子节点添加到待处理节点列表中
	}
	for len(nodes) > 0 { // 当还有待处理节点时
		nd := nodes[0]                        // 取出一个节点
		nodes = nodes[1:]                     // 更新待处理节点列表
		for key, child := range nd.children { // 遍历当前节点的所有子节点
			nodes = append(nodes, child) // 将子节点添加到待处理节点列表中
			cur := nd                    // 从当前节点开始
			for cur != nil {             // 当还有节点时
				if cur.fail == nil { // 如果当前节点的失败链为空，说明已经回溯到根节点
					child.fail = n // 子节点的失败链指向根节点
					break
				}
				if fail, ok := cur.fail.children[key]; ok { // 如果当前节点的失败链的子节点中有与当前字符相同的节点
					child.fail = fail // 子节点的失败链指向该节点
					break
				}
				cur = cur.fail // 否则，回溯到失败链指向的节点
			}
		}
	}
}

// 在节点中查找字符
func (n *node) find(chars []rune) []scope {
	var scopes []scope // 用于存储所有匹配的模式串的范围
	size := len(chars) // 输入的字符数组的长度
	cur := n           // 从根节点开始

	for i := 0; i < size; i++ { // 遍历输入的所有字符
		child, ok := cur.children[chars[i]] // 查找当前节点的子节点中是否有与当前字符相同的节点
		if ok {                             // 如果有，移动到该节点
			cur = child
		} else { // 如果没有，通过失败链回溯，直到找到一个与当前字符相同的节点或回溯到根节点
			for cur != n {
				cur = cur.fail
				if child, ok = cur.children[chars[i]]; ok {
					cur = child
					break
				}
			}

			if child == nil { // 如果没有找到与当前字符相同的节点，跳过当前字符
				continue
			}
		}

		for child != n { // 从当前节点开始，通过失败链回溯，直到回溯到根节点
			if child.end { // 如果当前节点是一个模式串的结束节点，说明找到了一个匹配的模式串
				scopes = append(scopes, scope{ // 将匹配的模式串的范围添加到结果中
					start: i + 1 - child.depth, // 起始位置为当前位置减去模式串的长度
					stop:  i + 1,               // 结束位置为当前位置
				})
			}
			child = child.fail // 回溯到失败链指向的节点
		}
	}

	return scopes // 返回所有匹配的模式串的范围
}
